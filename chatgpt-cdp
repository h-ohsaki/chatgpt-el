#!/usr/bin/env python3
#
# Remotely control AIs via Chromium browser using CDP protocol.
# Copyright (c) 2025, Hiroyuki Ohsaki.
# All rights reserved.
#

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import itertools
import json
import requests
import sys
import time
import collections

from perlcompat import die, warn, getopts
import tbdump
import websocket

DEFAULT_TIMEOUT = 10

Config = collections.namedtuple(
    'Config', 'url form_sel button_sel response_sel stop_sel')

CONFIGS = {
    'chatgpt':
    Config(
        url='https://chatgpt.com',
        form_sel='div#prompt-textarea',
        button_sel='button#composer-submit-button[data-testid="send-button"]',
        response_sel='article > h6 + div',
        stop_sel='button[aria-label="Stop streaming"]'),
    'gemini':
    Config(url='https://gemini.google.com/',
           form_sel='div.textarea',
           button_sel='button[aria-label="Send message"]',
           response_sel='response-container',
           stop_sel='button[aria-label="Stop response"]'),
    'openwebui':
    Config(url='http://vcserv:8080/',
           form_sel='div#chat-input',
           button_sel='button#send-message-button',
           response_sel='div#response-content-container',
           stop_sel='button.rounded-full'),
    'claude':
    Config(url='https://claude.ai/',
           form_sel='p[data-placeholder]',
           button_sel='button[aria-label="Send message"]',
           response_sel='div[data-test-render-count]',
           stop_sel='button[aria-label="Stop response"]'),
    'copilot':
    Config(url='https://copilot.microsoft.com/',
           form_sel='textarea[placeholder="Message Copilot"]',
           button_sel='button[aria-label="Submit message"]',
           response_sel='div[role="article"]',
           stop_sel='button[aria-label="Interrupt message"]'),
    'copilot-enterprise':
    Config(url='https://m365.cloud.microsoft/chat/',
           form_sel='span[aria-label="Message Copilot"]',
           button_sel='button[aria-label="Send"]',
           response_sel='div[data-testid="markdown-reply"]',
           stop_sel='button[aria-label="Stop generating"]'),
}

def usage():
    die(f"""\
usage: {sys.argv[0]} [-e engine] [-i] [-s prompt] [-r]
  -e engine   AI engine (default: ChatGPT)
  -i          open the AI engine in the browser
  -s prompt   submit the prompt to the AI engine
  -r          retrieve the current response in HTML format
""")

id_counter = itertools.count(1)

def cdb_send(ws, method, params=None):
    id_ = next(id_counter)
    req = {'id': id_, 'method': method}
    if params:
        req['params'] = params
    ws.send(json.dumps(req))
    ws.settimeout(DEFAULT_TIMEOUT)
    while True:
        resp = json.loads(ws.recv())
        if resp.get('id') == id_:
            return resp

def wait_until_visible(ws, selector):
    js = f"""
(function() {{
    const el = document.querySelector('{selector}');
    if (!el) return false;
    const style = window.getComputedStyle(el);
    return (style && style.display !== 'none' && style.visibility !== 'hidden');
}})()
"""
    for i in range(DEFAULT_TIMEOUT):
        resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})
        if resp['result']['result']['value']:
            return
        time.sleep(1)
    raise TimeoutError

def open_wsocket(config):
    # Identify the first page.
    resp = requests.get('http://127.0.0.1:9000/json/list',
                        timeout=DEFAULT_TIMEOUT)
    pages = [elem for elem in resp.json() if elem['type'] == 'page']
    for page in pages:
        if config.url in page.get('url'):
            break
    # Create a WebScoket connection to the page.
    url = page.get('webSocketDebuggerUrl')
    ws = websocket.create_connection(url)
    cdb_send(ws, 'Page.enable')
    if config.url not in page.get('url'):
        cdb_send(ws, 'Page.navigate', {'url': config.url})
    return ws

def send_prompt(config, prompt):
    ws = open_wsocket(config)

    # Fill the textare with the prompt.
    wait_until_visible(ws, config.form_sel)
    js = f"document.querySelector('{config.form_sel}').focus();"
    resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})
    cdb_send(ws, 'Input.insertText', {'text': prompt})

    # Click the submit button.
    wait_until_visible(ws, config.button_sel)
    js = f"document.querySelector('{config.button_sel}').click();"
    resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})

def recv_response(config):
    ws = open_wsocket(config)

    # Dump the inner-html of the last response.
    wait_until_visible(ws, config.response_sel)
    js = f"Array.from(document.querySelectorAll('{config.response_sel}')).slice(-1)[0].innerHTML"
    resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})
    content = resp['result']['result']['value']
    print(content)

    # Check if stop button is visible.
    js = f"document.querySelector('{config.stop_sel}');"
    resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})
    is_busy = 'objectId' in resp['result']['result']
    if not is_busy:
        print('EOF')

def main():
    opt = getopts('vIe:m:s:r') or usage()
    verbose = opt.v
    engine = opt.e.lower() if opt.e else 'chatgpt'
    model = opt.m
    config = CONFIGS[engine]
    if opt.I:
        ws = open_wsocket(config)
        sys.exit()
    if opt.r:
        recv_response(config)
    else:
        prompt = opt.s if opt.s else sys.stdin.read().strip()
        send_prompt(config, prompt)

if __name__ == "__main__":
    main()

#!/usr/bin/env python3
#
# Remotely control AIs (ChatGPT/Gemini/Claude/DeepSeek) via Chrome/Chromium using CDP protocol
# Copyright (c) 2025, Hiroyuki Ohsaki.
# All rights reserved.
#

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import itertools
import json
import requests
import sys
import time

from perlcompat import die, warn, getopts
import tbdump
import websocket

DEFAULT_TIMEOUT = 5

PAGE_URL = 'https://chatgpt.com'
# NOTE: Selector must not contain a single quote (').
FORM_SELECTOR = 'div#prompt-textarea'
BUTTON_SELECTOR = 'button#composer-submit-button[data-testid="send-button"]'
REPLY_SELECTOR = 'article > h6 + div'

def usage():
    die(f"""\
usage: {sys.argv[0]} [-e engine] [-i] [-s query] [-r]
  -e engine  AI eingine (default: ChatGPT)
""")

id_counter = itertools.count(1)

def quote_html(s):
    map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '\"': '&quot;',
        "\'": '&#39;',
        '\n' : '</p><p>',
    }
    for c, astr in map.items():
        s = s.replace(c, astr)
    return '<p>' + s + '</p>'

def cdb_send(ws, method, params=None):
    id_ = next(id_counter)
    req = {'id': id_, 'method': method}
    if params:
        req['params'] = params
    ws.send(json.dumps(req))
    ws.settimeout(DEFAULT_TIMEOUT)
    while True:
        resp = json.loads(ws.recv())
        if resp.get('id') == id_:
            return resp

def wait_until_visible(ws, selector):
    js = f"""
(function() {{
    const el = document.querySelector('{selector}');
    if (!el) return false;
    const style = window.getComputedStyle(el);
    return (style && style.display !== 'none' && style.visibility !== 'hidden' && el.innerHTML.trim().length > 0);
}})()
"""
    while True:
        resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})
        if resp['result']['result']['value']:
            break
        time.sleep(1)

def open_wsocket():
    # Identify the first page.
    resp = requests.get('http://127.0.0.1:9000/json/list',
                        timeout=DEFAULT_TIMEOUT)
    pages = [elem for elem in resp.json() if elem['type'] == 'page']
    page = pages[0]

    # Create a WebScoket connection to the page.
    url = page.get('webSocketDebuggerUrl')
    ws = websocket.create_connection(url)
    cdb_send(ws, 'Page.enable')
    if PAGE_URL not in page.get('url'):
        cdb_send(ws, 'Page.navigate', {'url': 'https://chatgpt.com'})
    return ws

def send_query(query):
    ws = open_wsocket()

    # Fill the textare with the query.
    wait_until_visible(ws, FORM_SELECTOR)
    query = query.replace('\n', '\\n')
    quoted_query = quote_html(query)
    js = f"document.querySelector('{FORM_SELECTOR}').innerHTML = '{quoted_query}';"
    resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})

    # Click the submit button.
    wait_until_visible(ws, BUTTON_SELECTOR)
    js = f"document.querySelector('{BUTTON_SELECTOR}').click();"
    resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})

def recv_query():
    ws = open_wsocket()

    # Dump the inner-html of the last reply.
    wait_until_visible(ws, REPLY_SELECTOR)
    js = f"Array.from(document.querySelectorAll('{REPLY_SELECTOR}')).slice(-1)[0].innerHTML"
    resp = cdb_send(ws, 'Runtime.evaluate', {'expression': js})
    content = resp['result']['result']['value']
    print(content)

def main():
    opt = getopts('e:is:r') or usage()
    engine = opt.e if opt.e else 'chatgpt'
    engine = engine.lower()
    if engine != 'chatgpt':
        raise NotImplementedError
    if opt.i:
        ws = open_wsocket()
    if opt.s:
        query = opt.s
        send_query(query)
    if opt.r:
        time.sleep(1)
        print(recv_query())

if __name__ == "__main__":
    main()
